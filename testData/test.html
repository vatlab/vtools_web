<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        text {
            font: 10px sans-serif;
        }

        .plot {
            position: absolute;
        }

        #plot-canvas {
            z-index: 2;
        }

        #axis-svg {
            z-index: 1;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .tick line{
            opacity: 0.2;
        }

        .xaxis .tick line{
            visibility: hidden;
        }

    </style>
</head>
<body>
    <svg id="axis-svg" class="plot"></svg>
    <canvas id="plot-canvas" class="plot"></canvas>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.12/d3.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.0.0/lodash.min.js"></script>
<script>
    // constants
    // var numberPoints = 5000;
    var subsetSize = 150;
    var pointRadius = 6;
    var zoomEndDelay = 250;

    // timeout function
    var zoomEndTimeout;

    // save the index of the currently selected point
    var selectedPoint;

    // define all size variables
    var fullWidth = 500;
    var fullHeight = 500;
    var margin = {top: 10, right: 10, bottom: 30, left: 30};
    var width = fullWidth - margin.left - margin.right;
    var height = fullHeight - margin.top - margin.bottom;

    function median(values){
      if(values.length ===0) return 0;

      values.sort(function(a,b){
        return a-b;
      });

      var half = Math.floor(values.length / 2);
      return values[half];

    }

    d3.tsv("fake_pvalue.tsv",function(fdata){
        var numberPoints = fdata.length
        var chrs= new Set (fdata.map((ele)=>ele.chr))
        var myColor = d3.scale.category10()
        
        var offSets={0:{max:0,start:0}}
        for (let chr of chrs){
            var filterData=fdata.filter((ele)=>ele.chr===chr).map((ele)=>Number(ele.pos))
            offSets[chr]={min:Math.min(...filterData),max:Math.max(...filterData),start:offSets[chr-1].start+offSets[chr-1].max,median:median(filterData)}
        }
        delete offSets[0]
        var data=fdata.map((ele)=>({x:ele.pos-offSets[ele.chr].min+offSets[ele.chr].start,y:-Math.log10(ele.pvalue),i:ele.id,chr:ele.chr,selected:false}))
        console.log(offSets)
        console.log(data)
            // generate random dataset
        // var randomX = d3.random.normal(0, 30);
        // var randomY = d3.random.normal(0, 30);

        // var data = d3.range(numberPoints).map(function(d, i) {
        //     return {
        //         x: randomX(),
        //         y: randomY(),
        //         i: i, // save the index of the point as a property, this is useful
        //         selected: false
        //     };
        // });

        // create a quadtree for fast hit detection
        var quadTree = d3.geom.quadtree(data);

        // selected 250 random numbers -- this is the subset of points
        // drawn during 'zoom' events
        var randomIndex = _.sampleSize(_.range(numberPoints), subsetSize);

        // the canvas is shifted by 1px to prevent any artefacts
        // when the svg axis and the canvas overlap
        var canvas = d3.select("#plot-canvas")
            .attr("width", width - 1)
            .attr("height", height - 1)
            .style("transform", "translate(" + (margin.left + 1) +
                "px" + "," + (margin.top + 1) + "px" + ")");

        var svg = d3.select("#axis-svg")
            .attr("width", fullWidth)
            .attr("height", fullHeight)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," +
                margin.top + ")");

        // ranges, scales, axis, objects
        var xRange = d3.extent(data, function(d) { return d.x });
        var yRange = d3.extent(data, function(d) { return d.y });

        var xScale = d3.scale.linear()
            .domain([xRange[0] - 5, xRange[1] + 5])
            .range([0, width]);

        var yScale = d3.scale.linear()
            .domain([0, yRange[1] + 3])
            .range([height, 0]);

        var xdata =[]
        var xdataMap={}
        Object.keys(offSets).forEach(key=>{
            let value=offSets[key].median+offSets[key].start;
            xdata.push(value);
            xdataMap[value]=key;
        })
        console.log(xdata)
        console.log(xdataMap)
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .innerTickSize(-height)
            .outerTickSize(0)
            .tickPadding(10)
            .orient('bottom')
            .ticks(10)
            .tickValues(xdata)
            .tickFormat(function(d){
                if (d in xdataMap){
                    return xdataMap[d];
                }else{
                    return d;
                }
            })

        var xAxisSvg = svg.append('g')
            .attr('class', 'xaxis axis')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxis);

        var yAxis = d3.svg.axis()
            .scale(yScale)
            .innerTickSize(-width)
            .outerTickSize(0)
            .orient('left');

       var yAxisSvg = svg.append('g')
            .attr('class', 'yaxis axis')
            .call(yAxis);

        // create zoom behaviour
        var zoomBehaviour = d3.behavior.zoom()
            .x(xScale)
            // .y(yScale)
            .scaleExtent([1, 10])
            .on("zoom", onZoom)
            .on("zoomend", onZoomEnd);

    // add zoom behaviour
        canvas.call(zoomBehaviour);




        // get the canvas drawing context
        var context = canvas.node().getContext('2d');

        draw();

            // the draw function draws the full dataset if no index
        // parameter supplied, otherwise it draws a subset according
        // to the indices in the index parameter
        function draw(index) {
            var active;

            quadTree = d3.geom.quadtree(data);
            svg.select("#chr").remove();
            svg.select(".xaxis").remove();


            svg.append('g')
            .attr('class', 'xaxis axis')
            .attr('transform', 'translate(0,' + height + ')')
            .call(xAxis);


            // on onclick handler
            canvas.on("click", onClick);

            

            context.clearRect(0, 0, fullWidth, fullHeight);
            context.fillStyle = 'steelblue';
            context.strokeWidth = 1;
            context.strokeStyle = 'white';

            // if an index parameter is supplied, we only want to draw points
            // with indices in that array
            if(index) {
                index.forEach(function(i) {
                    var point = data[i];
                    // if(!point.selected) {
                        drawPoint(point, pointRadius);
                    // }
                    // else {
                        // active = point;
                    // }
                });
            }
            // draw the full dataset otherwise
            else {
                console.log("draw all")
                data.forEach(function(point) {
                    if(!point.selected) {
                        drawPoint(point, pointRadius);
                    }
                    else {
                        active = point;
                    }
                });
            }

            // ensure that the actively selected point is drawn last
            // so it appears at the top of the draw order
            if(active) {
                context.fillStyle = 'red';
                drawPoint(active, pointRadius);
                context.fillStyle = 'steelblue';
            }
        }


        function drawChr(index,selectedChr){
            clearTimeout(zoomEndTimeout);
            console.log("draw chr")
            context.clearRect(0, 0, fullWidth, fullHeight);
            context.strokeWidth = 1;
            context.strokeStyle = 'white';
            var scale=1
            // var translate=[offSets[selectedChr].start,offSets[selectedChr].start+offSets[selectedChr].max]
            var chr_scale=d3.scale.linear()
                .domain([offSets[selectedChr].start - 5, offSets[selectedChr].start+offSets[selectedChr].max + 5])
                .range([0, width]);
            svg.select(".xaxis").remove();
            svg.select("#chr").remove();
            // var chrxAxis = d3.svg.axis().tickSize(0)

            // var chrxAxisSvg = svg.append('g')
            //     .attr('class', 'x axis')
            //     .attr('transform', 'translate(0,' + height + ')')
            //     .call(chrxAxis);
     
            index.forEach(function(i) {
                var point = data[i];
                drawChrPoint(point, pointRadius,chr_scale);
                // chrxAxisSvg.call(chrxAxis);

            });
            svg.append("text")
                .attr("id","chr")
                .attr("text-anchor", "middle") 
                .attr("transform", "translate("+ (width/2) +","+(height+20)+")") 
                .text("chr"+selectedChr);


            function onChrClick() {
                console.log("onChrClick called")
                 var mouse = d3.mouse(this);

                // map the clicked point to the data space
                var xClicked = chr_scale.invert(mouse[0]);
                var yClicked = yScale.invert(mouse[1]);
                var closest = quadTree.find([xClicked, yClicked]);
                console.log(closest)

            
            }

            canvas.on("click", onChrClick);

                
        }

        function drawChrPoint(point,r,chr_scale){
            var cx = chr_scale(point.x);
            var cy = yScale(point.y);
            context.beginPath();
            context.arc(cx, cy, r, 0, 2 * Math.PI);
            context.closePath();
            context.fillStyle=myColor(point.chr)
            context.fill();
            context.stroke();

        }



        function drawPoint(point, r) {
            var cx = xScale(point.x);
            var cy = yScale(point.y);
            // NOTE; each point needs to be drawn as its own path
            // as every point needs its own stroke. you can get an insane
            // speed up if the path is closed after all the points have been drawn
            // and don't mind points not having a stroke
            context.beginPath();
            context.arc(cx, cy, r, 0, 2 * Math.PI);
            context.closePath();
            context.fillStyle=myColor(point.chr)
            context.fill();
            context.stroke();
        }

         function onClick() {
            console.log("onClick called")
            var mouse = d3.mouse(this);

            // map the clicked point to the data space
            var xClicked = xScale.invert(mouse[0]);
            var yClicked = yScale.invert(mouse[1]);
            // find the closest point in the dataset to the clicked point
            var closest = quadTree.find([xClicked, yClicked]);

            // map the co-ordinates of the closest point to the canvas space
            var dX = xScale(closest.x);
            var dY = yScale(closest.y);
            var selectedChr= closest.chr
            var chrData = data.filter((ele)=>ele.chr===selectedChr)

            quadTree = d3.geom.quadtree(chrData);

            drawChr(chrData.map((ele)=>ele.i),selectedChr)

            // // register the click if the clicked point is in the radius of the point
            // var distance = euclideanDistance(mouse[0], mouse[1], dX, dY);

            // if(distance < pointRadius) {
            //     if(selectedPoint) {
            //         data[selectedPoint].selected = false;
            //     }
            //     closest.selected = true;
            //     selectedPoint = closest.i;

            //     // redraw the points
            //     draw();
            // }
        }




        

        function onZoom() {
            clearTimeout(zoomEndTimeout);
            console.log("On zoom ", randomIndex.length)
            draw(randomIndex);
            xAxisSvg.call(xAxis);
            // yAxisSvg.call(yAxis);
        }

        function onZoomEnd() {
            // when zooming is stopped, create a delay before
            // redrawing the full plot
            zoomEndTimeout = setTimeout(function() {
                draw();
            }, zoomEndDelay);
        }

        

        function euclideanDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }

    })




   
</script>
</html>